{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"redispatcher Run distributed work asynchronously, backed by Redis Documentation : https://rafalstapinski.github.io/redispatcher Source Code : https://github.com/rafalstapinski/redispatcher redispatcher is a library and daemon for scheduling work and running it asynchronously (like Celery or dramatiq ). It allows you to execute background tasks asynchronously, like sending a welcome email after a user registers. Features Full intellisense support across your code, despite a distributed workload Easier and faster to set up and integrate than alternatives Super low overhead and completely non-blocking, thanks to asyncio Dependencies aioredis to publish to Redis queues and for your consumers to read from Redis pydantic to validate all messages and make sure they conform to the shape you specify Installation Install with poetry $ poetry add redispatcher or with pip $ pip install redispatcher Basic Usage Running your workers # my_consumer.py from redispatcher import BaseConsumer class MyConsumer ( BaseConsumer ): QUEUE = \"my-queue-key\" class Message ( BaseConsumer . Message ): email : str name : str registered : bool async def process_message ( self , message : Message ): print ( f \"processing message { message } \" ) ... # dispatcher.py from redispatcher import Redispatcher , RedispatcherConfig , ConsumerConfig from my_consumer import MyConsumer config = RedispatcherConfig ( redis_dsn = \"rediss://\" , consumers = [ ConsumerConfig ( consumer_class = MyConsumer ) ] ) if __name__ == \"__main__\" : dispatcher = Redispatcher ( config ) dispatcher . start () $ python dispatcher.py Publishing messages # endpoint.py from my_consumer import MyConsumer from clients import my_aioredis_client @app . post ( \"/signup\" ) async def signup () ... await MyConsumer . publish ( MyConsumer . Message ( email =... , name =... , registered = True ), my_aioredis_client ) ... Contributing If you have a suggestion on how to improve redispatcher or experience a bug file an issue at https://github.com/rafalstapinski/redispatcher/issues . If you want to contribute, open a PR at https://github.com/rafalstapinski/redispatcher . PyPi: https://pypi.org/project/redispatcher/","title":"About"},{"location":"#redispatcher","text":"Run distributed work asynchronously, backed by Redis Documentation : https://rafalstapinski.github.io/redispatcher Source Code : https://github.com/rafalstapinski/redispatcher redispatcher is a library and daemon for scheduling work and running it asynchronously (like Celery or dramatiq ). It allows you to execute background tasks asynchronously, like sending a welcome email after a user registers.","title":"redispatcher"},{"location":"#features","text":"Full intellisense support across your code, despite a distributed workload Easier and faster to set up and integrate than alternatives Super low overhead and completely non-blocking, thanks to asyncio","title":"Features"},{"location":"#dependencies","text":"aioredis to publish to Redis queues and for your consumers to read from Redis pydantic to validate all messages and make sure they conform to the shape you specify","title":"Dependencies"},{"location":"#installation","text":"Install with poetry $ poetry add redispatcher or with pip $ pip install redispatcher","title":"Installation"},{"location":"#basic-usage","text":"","title":"Basic Usage"},{"location":"#running-your-workers","text":"# my_consumer.py from redispatcher import BaseConsumer class MyConsumer ( BaseConsumer ): QUEUE = \"my-queue-key\" class Message ( BaseConsumer . Message ): email : str name : str registered : bool async def process_message ( self , message : Message ): print ( f \"processing message { message } \" ) ... # dispatcher.py from redispatcher import Redispatcher , RedispatcherConfig , ConsumerConfig from my_consumer import MyConsumer config = RedispatcherConfig ( redis_dsn = \"rediss://\" , consumers = [ ConsumerConfig ( consumer_class = MyConsumer ) ] ) if __name__ == \"__main__\" : dispatcher = Redispatcher ( config ) dispatcher . start () $ python dispatcher.py","title":"Running your workers"},{"location":"#publishing-messages","text":"# endpoint.py from my_consumer import MyConsumer from clients import my_aioredis_client @app . post ( \"/signup\" ) async def signup () ... await MyConsumer . publish ( MyConsumer . Message ( email =... , name =... , registered = True ), my_aioredis_client ) ...","title":"Publishing messages"},{"location":"#contributing","text":"If you have a suggestion on how to improve redispatcher or experience a bug file an issue at https://github.com/rafalstapinski/redispatcher/issues . If you want to contribute, open a PR at https://github.com/rafalstapinski/redispatcher . PyPi: https://pypi.org/project/redispatcher/","title":"Contributing"},{"location":"advanced_usage/","text":"","title":"Advanced usage"},{"location":"contributing/","text":"Contributing to redispatcher redispatcher is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing"},{"location":"contributing/#contributing-to-redispatcher","text":"redispatcher is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing to redispatcher"},{"location":"getting_started/","text":"","title":"Getting started"},{"location":"overview/","text":"Overview redispatcher can be broken down into three (ish) parts. Consumer It all begins with a consumer. A consumer is just a class that defines the structure of the mssages it will be listening for and a function that implements the logic for processing that message. Publishing Every consumer you define will provide you with an easy publish method that you can use to queue up messages. Because we use Pydantic, it will validate and ensure that any messages you send/receive have to be formatted correctly. Consumer Pool A consumer pool is a separate process that listens for all relevant messages queued up in Redis and dispatches them to the designated consumers to be processed.","title":"Overview"},{"location":"overview/#overview","text":"redispatcher can be broken down into three (ish) parts.","title":"Overview"},{"location":"overview/#consumer","text":"It all begins with a consumer. A consumer is just a class that defines the structure of the mssages it will be listening for and a function that implements the logic for processing that message.","title":"Consumer"},{"location":"overview/#publishing","text":"Every consumer you define will provide you with an easy publish method that you can use to queue up messages. Because we use Pydantic, it will validate and ensure that any messages you send/receive have to be formatted correctly.","title":"Publishing"},{"location":"overview/#consumer-pool","text":"A consumer pool is a separate process that listens for all relevant messages queued up in Redis and dispatches them to the designated consumers to be processed.","title":"Consumer Pool"}]}