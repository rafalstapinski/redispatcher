{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"redispatcher Dispatch and run distributed work asynchronously, brokered by Redis Documentation : https://rafalstapinski.github.io/redispatcher Source Code : https://github.com/rafalstapinski/redispatcher What is redispatcher redispatcher allows you to dispatch work that needs to be done in a process separate from your main program loop. This is useful in cases when you need to process some long running work that doesn't necessarily need to be done synchronously within your code. A classic example of this is sending a welcome email to a user as they sign up for your service. It's not necessary to wait for the results of sending an email, and it may take a few seconds to do so. redispatcher lets you fire-and-forget this work (as a message put into a Redis server) and have it be executed in the background, asynchronously, in a separate process (or machine) entirely. redispatcher comes in two parts: 1. A library that lets you define workers, define strongly typed messages sent to workers, and provides helper functions to facilitate dispatching that work 2. A daemon that runs your workers in a pool, consistently listening for any incoming messages to be processed Why use it There are certainly other solutions for orchestrating distributed workers. redispatcher aims to be super lightweight, very fast and simple to set up (there are many free cloud-hosted Redis solutions available), and has robust type validation and intellisense support. Features Full intellisense support across your code, despite a distributed workload Strongly typed message contract between your publishing code and consumer Minimal boilerplate required to setup and start publishing compared than most alternatives Minimal performance overhead and completely non-blocking, thanks to asyncio (and works with alternatives like uvloop ) Dependencies aioredis is used under the hood to publish message to and read messages from Redis pydantic is used to to validate messages conform to your strongly typed contracts Installation Install with poetry $ poetry add redispatcher or with pip $ pip install redispatcher Basic Usage Defining your worker from redispatcher import BaseConsumer class SendWelcomeEmail ( BaseConsumer ): QUEUE = \"send-welcome-email\" class Message ( BaseConsumer . Message ): email : str name : str async def process_message ( self , message : Message ): # construct an email and send it to the `message.email` address Dispatching work from clients import my_aioredis_client @app . post ( \"/register\" ) async def register ( ... ) ... message = SendWelcomeEmail . Message ( email =... , name =... , registered = True ) await SendWelcomeEmail . dispatch ( message , my_aioredis_client ) ... Running redispatcher from redispatcher import Redispatcher , RedispatcherConfig , ConsumerConfig config = RedispatcherConfig ( redis_dsn = \"redis://localhost:6379/0\" , consumers = [ ConsumerConfig ( consumer_class = SendWelcomeEmail , count = 2 ) ] ) if __name__ == \"__main__\" : dispatcher = Redispatcher ( config ) dispatcher . start () Contributing redispatcher is already used in production, but is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"About"},{"location":"#redispatcher","text":"Dispatch and run distributed work asynchronously, brokered by Redis Documentation : https://rafalstapinski.github.io/redispatcher Source Code : https://github.com/rafalstapinski/redispatcher","title":"redispatcher"},{"location":"#what-is-redispatcher","text":"redispatcher allows you to dispatch work that needs to be done in a process separate from your main program loop. This is useful in cases when you need to process some long running work that doesn't necessarily need to be done synchronously within your code. A classic example of this is sending a welcome email to a user as they sign up for your service. It's not necessary to wait for the results of sending an email, and it may take a few seconds to do so. redispatcher lets you fire-and-forget this work (as a message put into a Redis server) and have it be executed in the background, asynchronously, in a separate process (or machine) entirely. redispatcher comes in two parts: 1. A library that lets you define workers, define strongly typed messages sent to workers, and provides helper functions to facilitate dispatching that work 2. A daemon that runs your workers in a pool, consistently listening for any incoming messages to be processed","title":"What is redispatcher"},{"location":"#why-use-it","text":"There are certainly other solutions for orchestrating distributed workers. redispatcher aims to be super lightweight, very fast and simple to set up (there are many free cloud-hosted Redis solutions available), and has robust type validation and intellisense support.","title":"Why use it"},{"location":"#features","text":"Full intellisense support across your code, despite a distributed workload Strongly typed message contract between your publishing code and consumer Minimal boilerplate required to setup and start publishing compared than most alternatives Minimal performance overhead and completely non-blocking, thanks to asyncio (and works with alternatives like uvloop )","title":"Features"},{"location":"#dependencies","text":"aioredis is used under the hood to publish message to and read messages from Redis pydantic is used to to validate messages conform to your strongly typed contracts","title":"Dependencies"},{"location":"#installation","text":"Install with poetry $ poetry add redispatcher or with pip $ pip install redispatcher","title":"Installation"},{"location":"#basic-usage","text":"","title":"Basic Usage"},{"location":"#defining-your-worker","text":"from redispatcher import BaseConsumer class SendWelcomeEmail ( BaseConsumer ): QUEUE = \"send-welcome-email\" class Message ( BaseConsumer . Message ): email : str name : str async def process_message ( self , message : Message ): # construct an email and send it to the `message.email` address","title":"Defining your worker"},{"location":"#dispatching-work","text":"from clients import my_aioredis_client @app . post ( \"/register\" ) async def register ( ... ) ... message = SendWelcomeEmail . Message ( email =... , name =... , registered = True ) await SendWelcomeEmail . dispatch ( message , my_aioredis_client ) ...","title":"Dispatching work"},{"location":"#running-redispatcher","text":"from redispatcher import Redispatcher , RedispatcherConfig , ConsumerConfig config = RedispatcherConfig ( redis_dsn = \"redis://localhost:6379/0\" , consumers = [ ConsumerConfig ( consumer_class = SendWelcomeEmail , count = 2 ) ] ) if __name__ == \"__main__\" : dispatcher = Redispatcher ( config ) dispatcher . start ()","title":"Running redispatcher"},{"location":"#contributing","text":"redispatcher is already used in production, but is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing"},{"location":"advanced_usage/","text":"","title":"Advanced usage"},{"location":"contributing/","text":"Contributing to redispatcher redispatcher is already being used in production environments, but is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing"},{"location":"contributing/#contributing-to-redispatcher","text":"redispatcher is already being used in production environments, but is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing to redispatcher"},{"location":"getting_started/","text":"","title":"Getting started"},{"location":"overview/","text":"Overview redispatcher can be broken down into three (ish) parts. Consumer It all begins with a consumer. A consumer is just a class that defines the structure of the mssages it will be listening for and a function that implements the logic for processing that message. Publishing Every consumer you define will provide you with an easy publish method that you can use to queue up messages. Because we use Pydantic, it will validate and ensure that any messages you send/receive have to be formatted correctly. Consumer Pool A consumer pool is a separate process that listens for all relevant messages queued up in Redis and dispatches them to the designated consumers to be processed.","title":"Overview"},{"location":"overview/#overview","text":"redispatcher can be broken down into three (ish) parts.","title":"Overview"},{"location":"overview/#consumer","text":"It all begins with a consumer. A consumer is just a class that defines the structure of the mssages it will be listening for and a function that implements the logic for processing that message.","title":"Consumer"},{"location":"overview/#publishing","text":"Every consumer you define will provide you with an easy publish method that you can use to queue up messages. Because we use Pydantic, it will validate and ensure that any messages you send/receive have to be formatted correctly.","title":"Publishing"},{"location":"overview/#consumer-pool","text":"A consumer pool is a separate process that listens for all relevant messages queued up in Redis and dispatches them to the designated consumers to be processed.","title":"Consumer Pool"}]}